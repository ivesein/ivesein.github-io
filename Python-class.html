<!DOCTYPE html>
<html lang="zh">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="./theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="./theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="./theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Ivesein">
  <meta name="description" content="Posts and writings by Ivesein">

  <link href="http://ivesein.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ivesein-Blogs Atom" />

<meta name="keywords" content="Python">

  <title>
    Ivesein-Blogs
&ndash; Python面向对象  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href=".">
        <img src="/images/my_logo.png" alt="logo">
      </a>
      <h2><a href=".">Ivesein</a></h2>
      <p>C/C++  PYTHON  GIT/GITHUB.  Work @Linux</p>
      <ul>
        <li><a href="./pages/guan-yu-wo.html">关于我</a></li>
        <li><a href="./pages/wo-de-xiang-mu.html">我的项目</a></li>
	<li><a href="mailto:ivesein@outlook.com" target="_blank">EMAIL</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href=".">Index</a> &brvbar; <a href="./archives.html">Archives</a>
      &brvbar; <a href="http://ivesein.github.io/feeds/all.atom.xml">Atom</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="./Python-class.html">Python面向对象</a></h1>
  </div>
  <div class="article_text">
    <hr>
<p>Python从设计之处就已经是一门面向对象语言,所以在python中创建一个类和对象是很容易的.  </p>
<hr>
<h4>面向对象技术简介</h4>
<ul>
<li>类(Class):用来描述具有相同的属性和方法的对象的合集.它定义了该集合中每个对象所共有的属性和方法.对象是类的实例.</li>
<li>类变量:类变量在真个该实例化的对象中是公用的.类变量定义在类中,且在函数体之外.类变量通常不作为实例变量使用.</li>
<li>数据成员:类变量或者实例变量用于处理类及其实例对象的相关的数据.</li>
<li>方法重写:如果从父类继承的方法不能满足子类的需求,可以对其进行改写,这个过程叫做方法的覆盖(override),也称作方法的重写.</li>
<li>实例变量:定义在方法中的变量,只作用于当前实例的类.</li>
<li>继承:即一个派生类(derived class)继承基类(base class)的字段和方法.继承页允许把一个派生类的对象作为一个基类对象对待.例如.有这样一个设计:一个Dog类型的对象派生自Animal类,这是模拟"是一个(is-a)"关系(例如,Dog是一个Animal).</li>
<li>实例化:创建一个类的实例,类的具体对象.</li>
<li>方法:类中定义的函数.</li>
<li>对象:通过类定义的数据结构示例.对象包括两个数据成员(类变量和实例变量)和方法.</li>
</ul>
<hr>
<h4>创建类</h4>
<p>使用class语句来创建一个类,class之后为类名并以冒号结尾.  </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ClassName</span><span class="p">:</span>
    <span class="s1">&#39;类的帮助信息&#39;</span>        <span class="c1"># 类文档字符串</span>
    <span class="n">class_suite</span>        <span class="c1"># 类体</span>
</pre></div>


<p>类的帮助信息可以通过ClassName.__doc__查看.<br>
class_suite由类的成员,方法,数据属性组成.  </p>
<h5>创建一个简单的类</h5>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="s1">&#39;所有员工的基类&#39;</span>
    <span class="n">empCount</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">salary</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
        <span class="n">Emploee</span><span class="o">.</span><span class="n">empCount</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">displayCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s2">&quot;Total Employee  </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">Employee</span><span class="o">.</span><span class="n">empCount</span>

    <span class="k">def</span> <span class="nf">displayEmployee</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s2">&quot;Name: &quot;</span><span class="p">,</span><span class="n">sefl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;,salary: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span>
</pre></div>


<ul>
<li>empCount变量是一个类变量,它的值将在这个类的所有实例之间共享.你可以在类内部或类外部使用Employee.empCount来访问.</li>
<li>第一个方法 _<em>init_</em>()是一种特殊的方法,被称为类的构造函数或初始化方法,当创建这个类的实例时就会调用这个方法.</li>
<li>self代表类的实例,self在定义类的方法时是必须有的,虽然在调用时不必传入相应的参数.</li>
</ul>
<h5>self代表类的实例,而非类</h5>
<p>类的方法与普通的函数只有一个特别的区别:它们必须有一个额外的第一个参数名称,按照管理它的名称是self.  </p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Test</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">prt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">)</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>
<span class="n">t</span><span class="o">.</span><span class="n">prt</span><span class="p">()</span>
</pre></div>


<p>示例结果为:  </p>
<div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">__main__</span><span class="o">.</span><span class="n">Test</span> <span class="n">instance</span> <span class="n">at</span> <span class="mh">0x10d066878</span><span class="o">&gt;</span>
<span class="n">__main__</span><span class="o">.</span><span class="n">Test</span>
</pre></div>


<p>从结果可以看出,self代表类的实例,代表当前对象的地址,而self.class则指向类.<br>
<strong>self不是python关键字,把它换成其他自定义变量名也是可以的.</strong>  </p>
<hr>
<h4>创建类的实例对象</h4>
<p>要创建一个类的实例,你可以使用类的名称,并通过__init__方法接收参数.  </p>
<div class="highlight"><pre><span></span><span class="c1">#创建Employee类的第一个对象</span>
<span class="n">emp1</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s2">&quot;jack&quot;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span>
<span class="c1">#创建Employee类的第二个对象</span>
<span class="n">emp2</span> <span class="o">=</span> <span class="n">Employee</span><span class="p">(</span><span class="s2">&quot;rose&quot;</span><span class="p">,</span> <span class="mi">7000</span><span class="p">)</span>
</pre></div>


<h4>访问属性</h4>
<p>可以使用(.)来访问对象的属性:  </p>
<div class="highlight"><pre><span></span><span class="n">emp1</span><span class="o">.</span><span class="n">displayEmployee</span><span class="p">()</span>
<span class="n">emp2</span><span class="o">.</span><span class="n">displayEmployee</span><span class="p">()</span>
<span class="k">print</span> <span class="s2">&quot;Total Employee 5d &quot;</span> <span class="o">%</span><span class="n">Employee</span><span class="o">.</span><span class="n">empCount</span>
</pre></div>


<p>你可以添加,删除,修改类的属性:  </p>
<div class="highlight"><pre><span></span><span class="n">emp1</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">28</span>    <span class="c1"># 添加一个&#39;age&#39;属性</span>
<span class="n">emp1</span><span class="o">.</span><span class="n">age</span> <span class="o">=</span> <span class="mi">30</span>    <span class="c1"># 修改&#39;age&#39;属性</span>
<span class="k">del</span> <span class="n">emp1</span><span class="o">.</span><span class="n">age</span>     <span class="c1"># 删除&#39;age&#39;属性</span>
</pre></div>


<p>你也可以使用以下函数的方式来进行设置,访问和删除属性等操作:<br>
<em> getattr(obj,name[,default]):访问对象的属性.
</em> hasattr(obj,name):检查一个属性是否存在
<em> setattr(obj,name,value):设置一个属性.如果属性不存在,会创建一个新属性.
</em> delattr(obj,name):删除属性</p>
<hr>
<h4>Python内置类属性</h4>
<ul>
<li>_<em>dict_</em>:类的属性(包含一个字典,由类的数据属性组成)</li>
<li>_<em>doc_</em>:类的文档字符串</li>
<li>_<em>name_</em>:类名</li>
<li>_<em>module_</em>:类定义所在的模块(类的全名是'_<em>main_</em>.className',如果类位于一个导入模块mymod中,那么className.__module__等于mymod)</li>
<li>_<em>bases_</em>:类的所有父类构成元素(包含了一个由所有父类组成的元组)</li>
</ul>
<p>Python内置类属性调用示例如下:  </p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>

<span class="k">class</span> <span class="nc">Employee</span><span class="p">:</span>
    <span class="s1">&#39;所有员工的基类&#39;</span>
        <span class="n">empCount</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">salary</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">salary</span> <span class="o">=</span> <span class="n">salary</span>
        <span class="n">Emploee</span><span class="o">.</span><span class="n">empCount</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">displayCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s2">&quot;Total Employee  </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">Employee</span><span class="o">.</span><span class="n">empCount</span>

    <span class="k">def</span> <span class="nf">displayEmployee</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s2">&quot;Name: &quot;</span><span class="p">,</span><span class="n">sefl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s2">&quot;,salary: &quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">salary</span>

<span class="k">print</span> <span class="s2">&quot;Employee.__doc__: &quot;</span><span class="p">,</span> <span class="n">Employee</span><span class="o">.</span><span class="vm">__doc__</span>
<span class="k">print</span> <span class="s2">&quot;Employee.__name__: &quot;</span><span class="p">,</span> <span class="n">Employee</span><span class="o">.</span><span class="vm">__name__</span>
<span class="k">print</span> <span class="s2">&quot;Employee.__module__: &quot;</span><span class="p">,</span> <span class="n">Employee</span><span class="o">.</span><span class="vm">__module__</span>
<span class="k">print</span> <span class="s2">&quot;Employee.__bases__: &quot;</span><span class="p">,</span> <span class="n">Employee</span><span class="o">.</span><span class="vm">__bases__</span>
<span class="k">print</span> <span class="s2">&quot;Employee.__dict__: &quot;</span><span class="p">,</span> <span class="n">Employee</span><span class="o">.</span><span class="vm">__dict__</span>
</pre></div>


<p>示例结果为:  </p>
<div class="highlight"><pre><span></span><span class="n">Employee</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">:</span> <span class="err">所有员工的基类</span>
<span class="n">Employee</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span> <span class="n">Employee</span>
<span class="n">Employee</span><span class="o">.</span><span class="vm">__module__</span><span class="p">:</span> <span class="n">__main__</span>
<span class="n">Employee</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span> <span class="p">()</span>
<span class="n">Employee</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;__module__&#39;</span><span class="p">:</span> <span class="s1">&#39;__main__&#39;</span><span class="p">,</span> <span class="s1">&#39;displayCount&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">displayCount</span> <span class="n">at</span> <span class="mh">0x10a939c80</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;empCount&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;displayEmployee&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="n">displayEmployee</span> <span class="n">at</span> <span class="mh">0x10a93caa0</span><span class="o">&gt;</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\xe6\x89\x80\xe6\x9c\x89\xe5\x91\x98\xe5\xb7\xa5\xe7\x9a\x84\xe5\x9f\xba\xe7\xb1\xbb</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;__init__&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">function</span> <span class="fm">__init__</span> <span class="n">at</span> <span class="mh">0x10a939578</span><span class="o">&gt;</span><span class="p">}</span>
</pre></div>


<hr>
<h4>python对象销毁(垃圾回收)</h4>
<p>python使用了引用计数这一简单技术来跟踪和回收垃圾.<br>
在python内部记录着所有使用中的对象各有多少引用.<br>
一个内部跟踪变量,称为一个引用计数器.<br>
对象被创建时,就创建了一个引用计数器,当这个对象不再需要时,也就是说这个对象的引用计数变为0时,它被垃圾回收.但是回收不是"立即"的,由解释器在适当的时机,将垃圾对象占用的内存空间回收.  </p>
<div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="mi">40</span>    <span class="c1"># 创建对象 &lt;40&gt;</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span>     <span class="c1"># 增加引用, &lt;40&gt;的计数</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>   <span class="c1"># 增加引用, &lt;40&gt;的计数</span>

<span class="k">del</span> <span class="n">a</span>     <span class="c1"># 减少引用 &lt;40&gt; 的计数</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">100</span>   <span class="c1"># 减少引用 &lt;40&gt; 的计数</span>
<span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># 减少引用 &lt;40&gt; 的计数</span>
</pre></div>


<p>垃圾回收机制不仅针对引用计数为0的对象,同样也可以处理循环引用的情况.循环引用指的是,两个对象相互引用,但是没有其他变量引用他们.这种情况下,仅使用引用计数是不够的.python的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器.作为引用计数的补充,垃圾收集器也会留心被分配的总量很大(即未通过引用计数销毁的那些)的对象.在这种情况下,解释器会暂停下来,试图清理所有未引用的循环.<br>
实例:<br>
析够函数_<em>del_</em>()在对象销毁时被调用  </p>
<div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>

<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="o">=</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">=</span><span class="n">y</span>
    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="k">print</span> <span class="n">class_name</span><span class="p">,</span><span class="s2">&quot;销毁&quot;</span>

<span class="n">pt1</span> <span class="o">=</span> <span class="n">Point</span><span class="p">()</span>
<span class="n">pt2</span> <span class="o">=</span> <span class="n">pt1</span>
<span class="n">pt3</span> <span class="o">=</span> <span class="n">pt1</span>
<span class="k">print</span> <span class="nb">id</span><span class="p">(</span><span class="n">pt1</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">pt2</span><span class="p">),</span> <span class="nb">id</span><span class="p">(</span><span class="n">pt3</span><span class="p">)</span>
<span class="k">del</span> <span class="n">pt1</span>
<span class="k">del</span> <span class="n">pt2</span>
<span class="k">del</span> <span class="n">pt3</span>
</pre></div>


<p>示例结果为:  </p>
<div class="highlight"><pre><span></span><span class="mi">3083401324</span> <span class="mi">3083401324</span> <span class="mi">3083401324</span>
<span class="n">Point</span> <span class="err">销毁</span>
</pre></div>


<p><strong>注意:通常你需要在单独的文件中定义一个类</strong></p>
<hr>
<h4>类的继承</h4>
<p><strong>继承语法:class 派生类名(基类名)//...基类名写在括号里,基本类是在类定义的是哈,在元组中指明的.</strong><br>
在python中继承的一些特点:<br>
<em> 1:在继承中基类的构造方法(_<em>init_</em>())不会被自动调用,它需要在其派生类的构造方法中亲自专门调用.<br>
</em> 2:在调用基类方法时.需要加上级类的类名前缀,且需要带上self参数.区别在于类中调用普通函数时并不需要带上self参数.
* 3:Python在嗯是首先查找对应类型的方法,如果它不能在派生类中找到对应的方法,它才开始到基类中诸葛查找.(现在本类中查找调用的方法,找不到才去基类中查找) </p>
<p>如果在继承元组中列了一个以上的父类,那么它被称作<strong>多重继承</strong>.<br>
你可以使用issubclass()或isinstance()方法来检测:<br>
<em> issubclass():判断一个类是另一个类的子类或者子孙类(issubclass(sub,sup))
</em> isinstance(obj,class):如果obj是class类的实例对象或者是一个class子类的实例对象则返回true</p>
<hr>
<h4>类的属性与方法</h4>
<h5>类的私有属性</h5>
<p><strong>__private_attrs:</strong>两个下划线开头,声明该属性为类私有属性,不能在类的外部被使用或直接访问.在类内部的方法中使用时用<strong>self.__private_attrs</strong>.  </p>
<h5>类的方法</h5>
<p>在类的内部,使用<strong>def</strong>关键字可以为类定义一个方法,与一般函数定义不同,类方法必须包含参数<strong>self</strong>,而且为第一个参数.  </p>
<h5>类的私有方法</h5>
<p><strong>__private_method:</strong>两个下划线开头,声明该方法为私有方法,不能在类外部调用,在类内部调用时使用**self.__private_method  </p>
<p>python不允许实例化的类访问私有数据,但你可以使用<strong>object._className_attrName</strong>访问类的私有属性</p>
  </div>
  <div class="article_meta">
    <p>Posted on: 2016-06-11(六)</p>
    <p>Category: <a href="./category/python.html">Python</a>
 &ndash; Tags:
      <a href="./tag/python.html">Python</a>    </p>
  </div>


</article>


    <div id="ending_message">
      <p>&copy; Ivesein. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>